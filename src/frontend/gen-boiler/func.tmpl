{% import 'macros.tmpl' as macros %}
#include "functions.h"

#include <cstdint>
#ifndef __USE_GNU
  #define __USE_GNU
  #define __USE_GNU_DEFINED
#endif
#include <dlfcn.h>
#ifdef __USE_GNU_DEFINED
  #undef __USE_GNU
  #undef __USE_GNU_DEFINED
#endif
#include <errno.h>
#include <grp.h>
#include <pwd.h>
#include <string>

#include "log.h"
#include "proc_utils.h"
#include "uds_client.h"

#define NUM_BUFF_SIZE 50

{% for func in fn_list %}
static {{func.ret}} (*real_{{func.name}})({{macros.fn_arg_types(func)}})=NULL;{% endfor %}


static void set_user_name(KVPair*& tmp_arg, const uid_t user_id)
{
    struct passwd pwd;
    struct passwd *result;
    char *buf = NULL;
    size_t bufsize = -1;

    bufsize = sysconf(_SC_GETPW_R_SIZE_MAX);
    if (bufsize <= 0) bufsize = 1024;

    buf = (char*)malloc(bufsize);
    if (buf == NULL)
    {
        DEBUG_LOG("[%s:%d]: malloc: %s\n", __FILE__, __LINE__, strerror(errno));
        tmp_arg->set_value("");
        return;
    }

    int ret = getpwuid_r(user_id, &pwd, buf, bufsize, &result);
    if (result == NULL)
    {
        if (ret == 0) DEBUG_LOG("[%s:%d]: User not found\n", __FILE__,__LINE__);
        else DEBUG_LOG("[%s:%d]: Error: %s\n", __FILE__, __LINE__, strerror(errno));

        tmp_arg->set_value("");
        free(buf);
        return;
    }

    tmp_arg->set_value(pwd.pw_name);
    free(buf);
}

static void set_group_name(KVPair*& tmp_arg, const gid_t group_id)
{
    struct group grp;
    struct group *result;
    char *buf = NULL;
    size_t bufsize = -1;

    bufsize = sysconf(_SC_GETGR_R_SIZE_MAX);
    if (bufsize <= 0) bufsize = 1024;

    buf = (char*)malloc(bufsize);
    if (buf == NULL)
    {
        DEBUG_LOG("[%s:%d]: malloc: %s\n", __FILE__, __LINE__, strerror(errno));
        tmp_arg->set_value("");
        return;
    }

    int ret = getgrgid_r(group_id, &grp, buf, bufsize, &result);
    if (result == NULL)
    {
        if (ret == 0) DEBUG_LOG("[%s:%d]: Group not found\n", __FILE__,__LINE__);
        else DEBUG_LOG("[%s:%d]: Error: %s\n", __FILE__, __LINE__, strerror(errno));

        tmp_arg->set_value("");
        free(buf);
        return;
    }

    tmp_arg->set_value(grp.gr_name);
    free(buf);
}

{% for func in fn_list -%}
extern "C" {{func.ret~" "~func.name}}({{macros.fn_arg_def(func)}}) {

  char *error = NULL;
  dlerror();

  if (!real_{{func.name}}) {
    DLSYM_CHECK(real_{{func.name}} = ({{func.ret}}(*)({{macros.fn_arg_types(func)}}))dlsym(RTLD_NEXT, "{{func.name}}"));
  }

  if (ProcUtils::test_and_set_flag(true))
    return (*real_{{func.name}})({{macros.fn_arg_call(func)}});

  uint64_t start_time = ProcUtils::get_time();
{% for arg in func.args if arg.read %}
  {% if arg.type == "FILE *" -%}
  int {{arg.name}}_fd = -1;
  if ({{arg.name}}) {{arg.name}}_fd = fileno({{arg.name}});
  {%- endif -%}
{%- endfor %}
  {% if func.ret != "void" -%}
  {{func.ret}} ret = (*real_{{func.name}})({{macros.fn_arg_call(func)}});
  {%- else -%}
  (*real_{{func.name}})({{macros.fn_arg_call(func)}});
  {%- endif %}
  int errno_value = errno;

  uint64_t end_time = ProcUtils::get_time();

  FuncInfoMessage func_msg;
  func_msg.set_func_name("{{func.name}}");

  KVPair* tmp_arg;
  char buffer[NUM_BUFF_SIZE];
{% for arg in func.args if arg.read %}
  tmp_arg = func_msg.add_args();
  tmp_arg->set_key("{{arg.name}}");
  {% if arg.type == "char *" or arg.type == "const char *" -%}
    std::string {{arg.name}}_value;
    if ({{arg.name}}) {{arg.name}}_value = {{arg.name}};
    tmp_arg->set_value({{arg.name}}_value);
  {%- elif arg.type == "FILE *" -%}
    memset(buffer, 0, sizeof buffer);
  snprintf(buffer, (sizeof buffer)-1, "%d", {{arg.name}}_fd);
  tmp_arg->set_value(buffer);
  {%- elif arg.type == "uid_t" -%}
    set_user_name(tmp_arg, {{arg.name}});
    //tmp_arg->set_value(getpwuid({{arg.name}})->pw_name);
  {%- elif arg.type == "gid_t" -%}
    set_group_name(tmp_arg, {{arg.name}});
    //tmp_arg->set_value(getgrgid({{arg.name}})->gr_name);
  {%- else -%}
    memset(buffer, 0, sizeof buffer);
  snprintf(buffer, (sizeof buffer)-1, {{printf_map[arg.type]}}, {{arg.name}});
  tmp_arg->set_value(buffer);
{%- endif -%}
{%- endfor %}

  {% if func.ret == "FILE *" -%}
    int ret_val = -1;
    if (ret) ret_val = fileno(ret);
    func_msg.set_ret_val(ret_val);
  {%- elif func.ret != "char *" and func.ret != "void" -%}
    func_msg.set_ret_val(ret);
  {%- endif %}
  func_msg.set_begin_time(start_time);
  func_msg.set_end_time(end_time);
  func_msg.set_error_num(errno_value);

  const uint64_t msg_size = func_msg.ByteSize();

  uint64_t current_time = ProcUtils::get_time();

  HeaderMessage hdr_msg;
  hdr_msg.set_timestamp(current_time);
  hdr_msg.set_pid((uint64_t)getpid());
  hdr_msg.set_payload_type(PayloadType::FUNCINFO_MSG);
  hdr_msg.set_payload_len(msg_size);

  ProcUtils::serialise_and_send_data(hdr_msg);
  ProcUtils::serialise_and_send_data(func_msg);

  ProcUtils::test_and_set_flag(false);
  {% if func.ret != "void" -%}
  return ret;
  {%- else -%}
  return;
  {%- endif %}
}


{% endfor %}

/*void initialise_interposition_functions() {
  char *error;
  dlerror();
{% for func in fn_list %}  DLSYM_CHECK(real_{{func.name}} = ({{func.ret}}(*)({{macros.fn_arg_types(func)}}))dlsym(RTLD_NEXT, "{{func.name}}"));{% if not loop.last %}{{"\n"}}{% endif %}{% endfor %}
}*/

