{% import 'macros.tmpl' as macros %}
#include "functions.h"

#include <cstdint>
#ifndef __USE_GNU
  #define __USE_GNU
  #define __USE_GNU_DEFINED
#endif
#include <dlfcn.h>
#ifdef __USE_GNU_DEFINED
  #undef __USE_GNU
  #undef __USE_GNU_DEFINED
#endif
#include <errno.h>
#include <grp.h>
#include <pwd.h>

#include "log.h"
#include "proc_utils.h"
#include "uds_client.h"

#define NUM_BUFF_SIZE 50

#define DLSYM_CHECK(A) if ((A)==NULL){ \
  DEBUG_LOG("[%s:%d]: %s\n", __FILE__, __LINE__, "Critical error, failed to dlsym a function correctly."); \
  if ((error = dlerror()) != NULL){ \
    DEBUG_LOG("[%s:%d]: %s\n", __FILE__, __LINE__, error); \
  } \
  exit(1); \
}

{% for func in fn_list %}
static {{func.ret}} (*real_{{func.name}})({{macros.fn_arg_types(func)}})=NULL;{% endfor %}


{% for func in fn_list -%}
extern "C" {{func.ret~" "~func.name}}({{macros.fn_arg_def(func)}}) {
  if (ProcUtils::test_and_set_flag(true))
    return (*real_{{func.name}})({{macros.fn_arg_call(func)}});

  uint64_t start_time = ProcUtils::get_time();
{% for arg in func.args if arg.read %}
  {% if arg.type == "FILE *" -%}
    int {{arg.name}}_fd = fileno({{arg.name}});
  {%- endif -%}
{%- endfor %}
  {% if func.ret != "void" -%}
  {{func.ret}} ret = (*real_{{func.name}})({{macros.fn_arg_call(func)}});
  {%- else -%}
  (*real_{{func.name}})({{macros.fn_arg_call(func)}});
  {%- endif %}
  int errno_value = errno;

  uint64_t end_time = ProcUtils::get_time();

  FuncInfoMessage func_msg;
  func_msg.set_func_name("{{func.name}}");

  KVPair* tmp_arg;
  char buffer[NUM_BUFF_SIZE];
{% for arg in func.args if arg.read %}
  tmp_arg = func_msg.add_args();
  tmp_arg->set_key("{{arg.name}}");
  {% if arg.type == "char *" or arg.type == "const char *" -%}
    tmp_arg->set_value({{arg.name}});
  {%- elif arg.type == "FILE *" -%}
    memset(buffer, 0, sizeof buffer);
  snprintf(buffer, (sizeof buffer)-1, "%d", {{arg.name}}_fd);
  tmp_arg->set_value(buffer);
  {%- elif arg.type == "uid_t" -%}
    tmp_arg->set_value(getpwuid({{arg.name}})->pw_name);
  {%- elif arg.type == "gid_t" -%}
    tmp_arg->set_value(getgrgid({{arg.name}})->gr_name);
  {%- else -%}
    memset(buffer, 0, sizeof buffer);
  snprintf(buffer, (sizeof buffer)-1, {{printf_map[arg.type]}}, {{arg.name}});
  tmp_arg->set_value(buffer);
{%- endif -%}
{%- endfor %}

  {% if func.ret == "FILE *" -%}
    func_msg.set_ret_val(fileno(ret));
  {%- elif func.ret != "char *" and func.ret != "void" -%}
    func_msg.set_ret_val(ret);
  {%- endif %}
  func_msg.set_begin_time(start_time);
  func_msg.set_end_time(end_time);
  func_msg.set_error_num(errno_value);

  const uint64_t msg_size = func_msg.ByteSize();

  uint64_t current_time = ProcUtils::get_time();

  HeaderMessage hdr_msg;
  hdr_msg.set_timestamp(current_time);
  hdr_msg.set_pid((uint64_t)getpid());
  hdr_msg.set_payload_type(PayloadType::FUNCINFO_MSG);
  hdr_msg.set_payload_len(msg_size);

  ProcUtils::serialise_and_send_data(hdr_msg);
  ProcUtils::serialise_and_send_data(func_msg);

  ProcUtils::test_and_set_flag(false);
  {% if func.ret != "void" -%}
  return ret;
  {%- else -%}
  return;
  {%- endif %}
}


{% endfor %}

void initialise_interposition_functions() {
  char *error;
  dlerror();
{% for func in fn_list %}  DLSYM_CHECK(real_{{func.name}} = ({{func.ret}}(*)({{macros.fn_arg_types(func)}}))dlsym(RTLD_NEXT, "{{func.name}}"));{% if not loop.last %}{{"\n"}}{% endif %}{% endfor %}
}

