{% import 'macros.tmpl' as macros %}

{% for func in fn_list %}
static {{func.ret}} (*real_{{func.name}})({{macros.fn_arg_types(func)}})=NULL;{% endfor %}

{% for func in fn_list -%}
extern "C" {{func.ret~" "~func.name}}({{macros.fn_arg_def(func)}})
{
    char *error = NULL;
    dlerror();

    if (!real_{{func.name}})
    {
        DLSYM_CHECK(real_{{func.name}} = ({{func.ret}}(*)({{macros.fn_arg_types(func)}}))dlsym(RTLD_NEXT, "{{func.name}}"));
    }

    if (ProcUtils::test_and_set_flag(true))
        return (*real_{{func.name}})({{macros.fn_arg_call(func)}});
    
    {% for arg in func.args if arg.read -%}
    {%- if arg.type == "FILE *" -%}
    int {{arg.name}}_fd = -1;
    if ({{arg.name}}) {{arg.name}}_fd = fileno({{arg.name}});
    {%- endif -%}
    {%- endfor %}
    uint64_t start_time = ProcUtils::get_time();

    {% if func.ret != "void" -%}
    {{func.ret}} ret = (*real_{{func.name}})({{macros.fn_arg_call(func)}});
    {%- else -%}
    (*real_{{func.name}})({{macros.fn_arg_call(func)}});
    {%- endif %}
    int errno_value = errno;

    uint64_t end_time = ProcUtils::get_time();

    FuncInfoMessage func_msg;
    func_msg.set_func_name("{{func.name}}");

    {% if func.args|capture_arg %}KVPair* tmp_arg;{% endif %}
    {% if func.args|buffer_arg %}char buffer[NUM_BUFF_SIZE];{% endif %}
    {% for arg in func.args if arg.read %}
    tmp_arg = func_msg.add_args();
    tmp_arg->set_key("{{arg.name}}");
    {% if arg.type == "char *" or arg.type == "const char *" -%}
    std::string {{arg.name}}_value;
    if ({{arg.name}}) {{arg.name}}_value = {{arg.name}};
    tmp_arg->set_value({{arg.name}}_value);
    {%- elif arg.type == "FILE *" -%}
    memset(buffer, 0, sizeof buffer);
    snprintf(buffer, (sizeof buffer)-1, "%d", {{arg.name}}_fd);
    tmp_arg->set_value(buffer);
    {%- elif arg.type == "uid_t" -%}
    tmp_arg->set_value(ProcUtils::get_user_name({{arg.name}}));
    {%- elif arg.type == "gid_t" -%}
    tmp_arg->set_value(ProcUtils::get_group_name({{arg.name}}));
    {%- else -%}
    memset(buffer, 0, sizeof buffer);
    snprintf(buffer, (sizeof buffer)-1, {{printf_map[arg.type]}}, {{arg.name}});
    tmp_arg->set_value(buffer);
    {%- endif -%}
    {%- endfor %}

    {% if func.ret == "FILE *" -%}
    int ret_val = -1;
    if (ret) ret_val = fileno(ret);
    func_msg.set_ret_val(ret_val);
    {%- elif func.ret != "char *" and func.ret != "void" -%}
    func_msg.set_ret_val(ret);
    {%- endif %}
    func_msg.set_begin_time(start_time);
    func_msg.set_end_time(end_time);
    func_msg.set_error_num(errno_value);

    const uint64_t msg_size = func_msg.ByteSize();

    uint64_t current_time = ProcUtils::get_time();

    Header hdr_msg;
    hdr_msg.set_timestamp(current_time);
    hdr_msg.set_pid((uint64_t)getpid());
    hdr_msg.set_payload_type(PayloadType::FUNCINFO_MSG);
    hdr_msg.set_payload_len(msg_size);

    ProcUtils::serialise_and_send_data(hdr_msg, func_msg);

    ProcUtils::test_and_set_flag(false);
    {% if func.ret != "void" -%}
    return ret;
    {%- else -%}
    return;
    {%- endif %}
}


{% endfor %}
