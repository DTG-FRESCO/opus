#! /usr/bin/env python2.7
# -*- coding: utf-8 -*-
from __future__ import (absolute_import, division,
                        print_function)


import argparse
import functools
import hashlib
import os
import os.path
import sys
import time

try:
    import prettytable
    import psutil
    import yaml
    from termcolor import colored
except ImportError as exe:
    if '-v' in sys.argv:
        print(exe.message)
    sys.exit(1)

OPUS_AVAILABLE = True
try:
    from opus import cc_utils, exception
except ImportError as exc:
    OPUS_AVAILABLE = False


class OPUSctlError(Exception):
    pass


class FailedConfigError(OPUSctlError):
    pass


def memoised(func):
    cache = func.cache = {}

    @functools.wraps(func)
    def inner(*args, **kwargs):
        key = str(args) + str(kwargs)
        if key not in cache:
            cache[key] = func(*args, **kwargs)
        return cache[key]
    return inner


@memoised
def path_normalise(path):
    return os.path.abspath(os.path.expanduser(path))


DEFAULT_CONFIG_PATH = "~/.opus-cfg"

if 'OPUS_MASTER_CONFIG' in os.environ:
    CONFIG_PATH = path_normalise(os.environ['OPUS_MASTER_CONFIG'])
else:
    CONFIG_PATH = path_normalise(DEFAULT_CONFIG_PATH)

CONFIG_SETUP = [
    {'key': 'master_config',
     'def': lambda _: DEFAULT_CONFIG_PATH,
     'prompt': 'Choose a location for the OPUS master config'},

    {'key': 'install_dir',
     'def': lambda _: '~/.opus',
     'prompt': 'Choose a directory for your OPUS installation to reside in'},

    {'key': 'uds_path',
     'def': lambda cfg: os.path.join(cfg['install_dir'], 'uds_sock'),
     'prompt': 'Choose a location for the OPUS Unix Domain Socket'},

    {'key': 'db_path',
     'def': lambda cfg: os.path.join(cfg['install_dir'], 'prov.neo4j'),
     'prompt': 'Choose a location for the OPUS database to reside in'},

    {'key': 'bash_var_path',
     'def': lambda _: '~/.opus-vars',
     'prompt': 'Choose a location for the OPUS bash variables cfg_file'},

    {'key': 'python_binary',
     'def': lambda _: '/usr/bin/python2.7',
     'prompt': 'What is the location of your python 2.7 binary'},

    {'key': 'java_home',
     'def': lambda _: '/usr/lib/jvm/java-7-common',
     'prompt': 'Where is your jvm installation'},

    {'key': 'cc_port',
     'def': lambda _: '10101',
     'prompt': 'Port to use for provenance server communications.'},

    {'key': 'debug_mode',
     'def': lambda _: False,
     'prompt': 'Set OPUS to debug mode'}
]


BASH_VAR_TEMPLATE = """\
#Auto generated by opusctl
export PATH=$PATH:{bin_dir}
export PYTHONPATH=$PYTHONPATH:{lib_dir}:{py_dir}
export OPUS_MASTER_CONFIG={conf_loc}
"""


SERVER_CONFIG_TEMPLATE = """\
LOGGING:
  version: 1
  formatters:
    full:
      format: \"%(asctime)s %(levelname)s L%(lineno)d -> %(message)s\"
  handlers:
    file:
      class: logging.FileHandler
      level: DEBUG
      formatter: full
      filename: {log_file}
  root:
    level: {log_level}
    handlers: [file]

MODULES:
  Producer: SocketProducer
  Analyser: PVMAnalyser
  CommandInterface: TCPInterface

PRODUCER:
  SocketProducer:
    comm_mgr_type: UDSCommunicationManager
    comm_mgr_args:
        uds_path: {uds_sock}
        max_conn: 10
        select_timeout: 5.0

ANALYSER:
  PVMAnalyser:
    storage_type: DBInterface
    storage_args:
      filename: {db_path}
    opus_lite: true

COMMANDINTERFACE:
  TCPInterface:
    listen_addr: localhost
    listen_port: {cc_port}

GENERAL:
  touch_file: {touch_file}
"""


def auto_read_config(func):
    @functools.wraps(func)
    def inner(config, *args, **kwargs):
        return func(cfg=load_config(config),
                    *args,
                    **kwargs)
    return inner


def skip_config(func):
    @functools.wraps(func)
    def wrap(config, *args, **kwargs):  # pylint: disable=unused-argument
        # Disable needed as args are passed by keyword
        return func(*args, **kwargs)
    return wrap


@memoised
def compute_config_check(cfg):
    sha1 = hashlib.sha1()

    cfg_str = yaml.dump(cfg)
    sha1.update(cfg_str)
    return cfg_str, sha1.hexdigest()


def is_opus_ipose_lib_set():
    return ("LD_PRELOAD" in os.environ and
            "libopusinterpose.so" in os.environ['LD_PRELOAD'])


def is_opus_active():
    return (is_opus_ipose_lib_set() and
            ("OPUS_INTERPOSE_MODE" in os.environ and
             os.environ['OPUS_INTERPOSE_MODE'] != "0"))


def read_config(config_path):
    if os.path.exists(config_path):
        try:
            with open(config_path, "r") as cfg_file:
                check = cfg_file.readline().rstrip()
                return (check, yaml.load(cfg_file.read()))
        except [yaml.error.YAMLError, IOError]:
            raise FailedConfigError()
    else:
        raise FailedConfigError()


def write_config(config_path, cfg):
    config_path = path_normalise(config_path)
    cfg_str, cfg_check = compute_config_check(cfg)
    with open(config_path, "w") as cfg_file:
        cfg_file.write(cfg_check)
        cfg_file.write("\n")
        cfg_file.write(cfg_str)


def load_config(config_path=CONFIG_PATH):
    try:
        check, cfg = read_config(config_path)
    except FailedConfigError:
        print("Error: Your config file is missing.")
        resp = raw_input("Do you want to regenerate it? [Y/n]")
        if resp == "" or resp.upper() == "Y":
            cfg = generate_config()
            check = ""
        else:
            raise

    _, cfg_check = compute_config_check(cfg)
    if check != cfg_check:
        update_config_subsidiaries(cfg)
        write_config(config_path, cfg)
    return cfg


def update_config_subsidiaries(cfg):
    print("Config file modified, applying...")
    generate_bash_var_file(cfg)
    generate_server_cfg_file(cfg)
    print("Application complete.")


def generate_config(existing=None):
    if existing is None:
        existing = {}
    cfg = {}

    for quest in CONFIG_SETUP:
        if quest['key'] in existing:
            default = existing[quest['key']]
        else:
            default = quest['def'](cfg)
        prompt = "{} [{}]:".format(quest['prompt'], default)
        resp = raw_input(prompt)
        if resp == "":
            cfg[quest['key']] = default
        else:
            cfg[quest['key']] = resp

    return cfg


def generate_bash_var_file(cfg):
    var_file_path = path_normalise(cfg['bash_var_path'])

    with open(var_file_path, "w") as var_file:
        var_file.write(
            BASH_VAR_TEMPLATE.format(
                bin_dir=path_normalise(
                    os.path.join(cfg['install_dir'], "bin")
                ),
                lib_dir=path_normalise(
                    os.path.join(cfg['install_dir'], "lib")
                ),
                py_dir=path_normalise(
                    os.path.join(cfg['install_dir'], "src", "backend")
                ),
                conf_loc=path_normalise(
                    cfg['master_config']
                )
            )
        )


def generate_server_cfg_file(cfg):
    server_cfg_path = path_normalise(os.path.join(cfg['install_dir'],
                                                  "opus-cfg.yaml"))

    log_level = "DEBUG" if cfg['debug_mode'] else "ERROR"
    log_file = path_normalise(os.path.join(cfg['install_dir'], "opus.log"))
    uds_sock = path_normalise(cfg['uds_path'])
    db_path = path_normalise(cfg['db_path'])
    touch_file = path_normalise(os.path.join(cfg['install_dir'], ".opus-live"))
    cc_port = cfg['cc_port']

    with open(server_cfg_path, "w") as server_cfg:
        server_cfg.write(
            SERVER_CONFIG_TEMPLATE.format(
                log_level=log_level,
                log_file=log_file,
                uds_sock=uds_sock,
                db_path=db_path,
                touch_file=touch_file,
                cc_port=cc_port))


def is_server_active():
    for proc in psutil.process_iter():
        if "opus.run_server" in " ".join(proc.cmdline()):
            return True
    return False


def elapsed(reset=False):
    if reset:
        elapsed.start = time.time()
    else:
        return time.time() - elapsed.start


def monitor_server_startup(cfg):
    if not OPUS_AVAILABLE:
        print("OPUS libraries not available in $PYTHONPATH, "
              "please check your environment and try again.")
        print("Unable to check OPUS server startup status.")
        print("Assuming server has started.")
        return True
    elapsed(reset=True)
    time.sleep(0.1)
    while elapsed() < 20:
        server_active = is_server_active()
        try:
            helper = cc_utils.CommandConnectionHelper("localhost",
                                                      int(cfg['cc_port']))
            helper.make_request({'cmd': 'status'})
            server_responsive = True
        except exception.BackendConnectionError:
            server_responsive = False

        yes = colored("yes", "green")
        no = colored("no", "red")

        print((" " * 50), end="\r")
        print("Server Active: %s Server Responsive: %s" %
              ((yes if server_active else no),
               (yes if server_responsive else no)),
              end="\r")
        sys.stdout.flush()
        if not(server_active or server_responsive):
            break

        if server_active and server_responsive:
            print("\nServer sucessfully started.")
            return True
        time.sleep(0.1)
    print("\nServer startup failed, check the %s and %s error logs for "
          "information." % (os.path.join(cfg['install_dir'], "opus_err.log"),
                            os.path.join(cfg['install_dir'], "opus.log")))
    return False


def start_opus_server(cfg):
    print("Attempting to start OPUS server.")
    if is_opus_active() or is_opus_ipose_lib_set():
        reset_opus_env(cfg)
    if 'JAVA_HOME' not in os.environ:
        os.environ['JAVA_HOME'] = cfg['java_home']

    try:
        pid = os.fork()
        if pid > 0:
            return monitor_server_startup(cfg)
    except OSError:
        sys.exit(1)

    os.chdir(path_normalise(cfg['install_dir']))
    os.setsid()
    os.umask(0)

    try:
        pid = os.fork()
        if pid > 0:
            sys.exit(0)
    except OSError:
        sys.exit(1)

    err_log = path_normalise(os.path.join(cfg['install_dir'], "opus_err.log"))
    sys.stdout.flush()
    sys.stderr.flush()
    sti = file("/dev/null", 'r')
    sto = open(err_log, 'w+')
    os.dup2(sti.fileno(), sys.stdin.fileno())
    os.dup2(sto.fileno(), sys.stdout.fileno())
    os.dup2(sto.fileno(), sys.stderr.fileno())
    sto.close()

    server_cfg_path = path_normalise(os.path.join(cfg['install_dir'],
                                                  "opus-cfg.yaml"))

    try:
        pid = os.fork()
        if pid > 0:
            os.waitpid(pid, 0)
        else:
            os.environ['PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION'] = 'cpp'
            os.environ['PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION_VERSION'] = '2'
            os.execvp(cfg['python_binary'],
                      [cfg['python_binary'],
                       "-O",
                       "-m",
                       "opus.run_server",
                       server_cfg_path])
    except OSError:
        sys.exit(1)


@auto_read_config
def handle_launch(cfg, binary, arguments):
    if not is_server_active():
        if not start_opus_server(cfg):
            print("Aborting command launch.")
            return

    opus_preload_lib = path_normalise(os.path.join(cfg['install_dir'],
                                                   'lib',
                                                   'libopusinterpose.so'))
    if 'LD_PRELOAD' in os.environ:
        if opus_preload_lib not in os.environ['LD_PRELOAD']:
            os.environ['LD_PRELOAD'] = (os.environ['LD_PRELOAD'] + " " +
                                        opus_preload_lib)
    else:
        os.environ['LD_PRELOAD'] = opus_preload_lib

    os.environ['OPUS_UDS_PATH'] = path_normalise(cfg['uds_path'])
    os.environ['OPUS_MSG_AGGR'] = "1"
    os.environ['OPUS_MAX_AGGR_MSG_SIZE'] = "65536"
    os.environ['OPUS_LOG_LEVEL'] = "3"  # Log critical
    os.environ['OPUS_INTERPOSE_MODE'] = "1"  # OPUS lite

    os.execvp(binary, [binary] + arguments)


def reset_opus_env(cfg):
    opus_vars = ['OPUS_INTERPOSE_MODE',
                 'OPUS_UDS_PATH',
                 'OPUS_MSG_AGGR',
                 'OPUS_MAX_AGGR_MSG_SIZE',
                 'OPUS_LOG_LEVEL']
    for var in opus_vars:
        if var in os.environ:
            del os.environ[var]

    opus_preload_lib = path_normalise(os.path.join(cfg['install_dir'],
                                                   'lib',
                                                   'libopusinterpose.so'))
    if 'LD_PRELOAD' in os.environ:
        if os.environ['LD_PRELOAD'] == opus_preload_lib:
            del os.environ['LD_PRELOAD']
        else:
            os.environ['LD_PRELOAD'] = os.environ['LD_PRELOAD'].replace(
                opus_preload_lib, ""
            ).strip()


@auto_read_config
def handle_exclude(cfg, binary, arguments):
    if is_opus_active():
        reset_opus_env(cfg)
    else:
        print("OPUS is not active.")
    os.execvp(binary, [binary] + arguments)


def handle_start(cfg):
    '''Starts OPUS server.'''
    if not is_server_active():
        start_opus_server(cfg)
    else:
        print("OPUS server already running.")


def handle_process(cmd, **params):
    if cmd == "launch":
        handle_launch(**params)
    elif cmd == "exclude":
        handle_exclude(**params)


def _calc_rem_time(msgs):
    this = _calc_rem_time
    if not hasattr(this, "msgs"):
        this.msgs = msgs
        this.time = time.time()
        return ""
    else:
        msg_diff = this.msgs-msgs
        time_diff = time.time()-this.time
        msg_per_s = msg_diff/time_diff
        rem_secs = int(msgs/msg_per_s)
        m, s = divmod(rem_secs, 60)
        h, m = divmod(m, 60)
        return "{:02d}:{:02d}:{:02d}".format(h, m, s)


def monitor_shutdown(helper, msg):
    print("Shutdown initiated.")
    print("Shutting down Producer...", end="")
    try:
        while True:
            ret = helper.make_request({"cmd": "status"})
            if ret['producer']['status'] == "Dead":
                break
    except exception.BackendConnectionError:
        pass
    print("Done.")
    print("Shutting down Analyser...")
    print("Flushing remaining messages...")
    total_msgs = msg['msg_count']
    try:
        while True:
            ret = helper.make_request({"cmd": "status"})
            if ret['analyser']['status'] == 'Dead':
                break
            cur_msg = ret['analyser']['num_msgs']

            rem_time = _calc_rem_time(cur_msg)

            print(" "*50, end="\r")
            print("{:.2f}% [{}/{}] {}".format((1-(cur_msg/total_msgs))*100,
                                              cur_msg, total_msgs, rem_time),
                  end="\r")
            sys.stdout.flush()

            time.sleep(2)
    except exception.BackendConnectionError:
        pass
    print(" "*50, end="\r")
    print("Message processing complete.")
    print("Shutdown complete.")


@auto_read_config
def handle_server(cfg, cmd, **params):
    if cmd == "start":
        handle_start(cfg=cfg, **params)
    else:
        if not is_server_active():
            print("Server is not running.")
            return

        if not OPUS_AVAILABLE:
            print("OPUS libraries not available in $PYTHONPATH, "
                  "please check your environment and try again.")
            return
        helper = cc_utils.CommandConnectionHelper("localhost",
                                                  int(cfg['cc_port']))

        msg = {"cmd": cmd}
        msg.update(params)
        pay = helper.make_request(msg)

        if not pay['success']:
            print(pay['msg'])
        elif cmd == "stop":
            monitor_shutdown(helper, pay)
        elif cmd == "ps":
            tab = prettytable.PrettyTable(['Pid',
                                           'Command Line',
                                           'Thread Count'])
            print("Interposed Processes:\n\n")
            for pid, count in pay['pid_map'].items():
                cmd_line = " ".join(
                    psutil.Process(
                        int(pid)
                        ).cmdline()
                    )
                tab.add_row([pid, cmd_line, count])
            print(tab)
        elif cmd == "status":
            print_status_rsp(pay)
        else:
            print(pay['msg'])


def handle_conf(config, install):
    try:
        _, cfg = read_config(config)
    except FailedConfigError:
        cfg = {}

    if config is not None:
        cfg['master_config'] = config

    new_cfg = generate_config(cfg)

    update_config_subsidiaries(new_cfg)

    write_config(new_cfg['master_config'], new_cfg)

    if install:
        with open("/tmp/install-opus", "w") as handle:
            handle.write("source " + new_cfg['bash_var_path'])


def handle_util(cmd, **params):
    if cmd == "ps-line":
        handle_ps_line(**params)


@skip_config
def handle_ps_line(mode):
    term_status = is_opus_ipose_lib_set()
    server_status = is_server_active()
    if mode == "unicode":
        if term_status:
            if server_status:
                print(u"☑".encode("utf-8"), end="")
            else:
                print(u"☒".encode("utf-8"), end="")
    elif mode == "return":
        return_code = 0
        if server_status:
            return_code |= 0b1
        if term_status:
            return_code |= 0b10
        sys.exit(return_code)


def print_status_rsp(pay):
    '''Prints status response to stdout'''

    print("{0:<20} {1:<12}".format("Producer", pay['producer']['status']))

    if 'num_msgs' in pay['analyser']:
        print("{0:<20} {1:<12} {2:<20}".format(
            "Analyser",
            pay['analyser']['status'],
            "(" + str(pay['analyser']['num_msgs']) + " msgs in queue)"))
    else:
        print("{0:<20} {1:<12}".format("Analyser", pay['analyser']['status']))

    print("{0:<20} {1:<12}".format("Query Interface", pay['query']['status']))


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("--config", required=False, default=CONFIG_PATH,
                        help="Path to OPUS master config file.")

    parser.add_argument("-v", action="store_true",
                        help="Print verbose errors.")

    group_parser = parser.add_subparsers(dest="group")
    proc_parser = group_parser.add_parser(
        "process",
        help="Commands for launching processes with or without OPUS "
             "interposition.")
    server_parser = group_parser.add_parser(
        "server",
        help="Commands for controlling the provenance collection server.")
    conf_parser = group_parser.add_parser(
        "conf",
        help="Configuration of the OPUS environment.")
    util_parser = group_parser.add_parser(
        "util",
        help="Utility functions for OPUS.")

    proc_cmds = proc_parser.add_subparsers(dest="cmd")

    launch = proc_cmds.add_parser(
        "launch",
        help="Launch a process under OPUS.")
    launch.add_argument(
        "binary", nargs='?', default=os.environ['SHELL'],
        help="The binary to be launched. Defaults to the current shell.")
    launch.add_argument(
        "arguments", nargs=argparse.REMAINDER,
        help="Any arguments to be passed.")

    exclude = proc_cmds.add_parser(
        "exclude",
        help="Launch a process excluded from OPUS interposition.")
    exclude.add_argument(
        "binary", nargs='?', default=os.environ['SHELL'],
        help="The binary to be launched. Defaults to the current shell.")
    exclude.add_argument(
        "arguments", nargs=argparse.REMAINDER,
        help="Any arguments to be passed.")

    server_cmds = server_parser.add_subparsers(dest="cmd")
    server_cmds.add_parser(
        "start",
        help="Start the OPUS provenance collection server.")
    server_cmds.add_parser(
        "stop",
        help="Stop the OPUS provenance collection server.")
    server_cmds.add_parser(
        "ps",
        help="Display a list of processes currently being interposed.")
    server_cmds.add_parser(
        "status",
        help="Display a status readout for the provenance collection server.")

    detach_parser = server_cmds.add_parser(
        "detach",
        help="Deactivates OPUS interposition on a running process.")
    detach_parser.add_argument(
        "pid", type=int,
        help="The PID requiring interposition deactivation.")

    server_cmds.add_parser("getan")

    setan_parser = server_cmds.add_parser("setan")
    setan_parser.add_argument("new_an")

    conf_parser.add_argument(
        "--install", "-i", action='store_true',
        help="Triggers additional output during the install procedure.")

    util_cmds = util_parser.add_subparsers(dest="cmd")
    ps_line_parser = util_cmds.add_parser(
        "ps-line",
        help="Provides a $PS line component for indicating the status "
             "of OPUS.")

    ps_mode = ps_line_parser.add_mutually_exclusive_group(required=True)
    ps_mode.add_argument("--unicode", dest="mode",
                         action="store_const", const="unicode",
                         help=u"Express OPUS status using unicode symbols. "
                         u"Prints nothing if the terminal interposition is "
                         u"off. Prints ☒ if the terminal is interposed but "
                         u"the server is off. Prints ☑ if both the terminal "
                         u"is interposed and the server is "
                         u"on.".encode("utf-8"))
    ps_mode.add_argument("--return", dest="mode",
                         action="store_const", const="return",
                         help="Express OPUS status as the return code of "
                         "this command. The return code of this command "
                         "encodes the status of the OPUS server and the "
                         "terminal interposition. The lowest bit gives "
                         "the server status and the next bit gives the "
                         "terminal status.")

    return parser.parse_args()


def main():
    try:
        args = parse_args()

        params = {k: v
                  for k, v in args._get_kwargs()  # pylint: disable=W0212
                  if k not in ['group', 'v']}

        if args.group == "process":
            handle_process(**params)
        elif args.group == "server":
            handle_server(**params)
        elif args.group == "conf":
            handle_conf(**params)
        elif args.group == "util":
            handle_util(**params)
    except FailedConfigError:
        print("Failed to execute command due to insufficient configuration. "
              "Please run the '{} conf' command "
              "to reconfigure the program.".format(sys.argv[0]))
    except KeyboardInterrupt:
        pass

if __name__ == "__main__":
    main()
