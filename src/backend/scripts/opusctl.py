#! /usr/bin/env python2.7
# -*- coding: utf-8 -*-
"""

"""
from __future__ import (absolute_import, division,
                        print_function)


import argparse
import functools
import hashlib
import os
import os.path
import sys

from opus import cc_utils
from opus import cc_msg_pb2 as cc_msg

import prettytable
import psutil
import yaml


class OPUSctlError(Exception):
    pass


class FailedConfigError(OPUSctlError):
    pass


def memoised(func):
    cache = func.cache = {}

    @functools.wraps(func)
    def inner(*args, **kwargs):
        key = str(args) + str(kwargs)
        if key not in cache:
            cache[key] = func(*args, **kwargs)
        return cache[key]
    return inner


@memoised
def path_normalise(path):
    return os.path.abspath(os.path.expanduser(path))


DEFAULT_CONFIG_PATH = "~/.opus-cfg"

if 'OPUS_MASTER_CONFIG' in os.environ:
    CONFIG_PATH = path_normalise(os.environ['OPUS_MASTER_CONFIG'])
else:
    CONFIG_PATH = path_normalise(DEFAULT_CONFIG_PATH)

CONFIG_SETUP = [
    {'key': 'master_config',
     'def': lambda _: DEFAULT_CONFIG_PATH,
     'prompt': 'Choose a location for the OPUS master config'},

    {'key': 'install_dir',
     'def': lambda _: '~/.opus',
     'prompt': 'Choose a directory for your OPUS installation to reside in'},

    {'key': 'uds_path',
     'def': lambda cfg: os.path.join(cfg['install_dir'], 'uds_sock'),
     'prompt': 'Choose a location for the OPUS Unix Domain Socket'},

    {'key': 'db_path',
     'def': lambda cfg: os.path.join(cfg['install_dir'], 'prov.neo4j'),
     'prompt': 'Choose a location for the OPUS database to reside in'},

    {'key': 'bash_var_path',
     'def': lambda _: '~/.opus-vars',
     'prompt': 'Choose a location for the OPUS bash variables cfg_file'},

    {'key': 'python_binary',
     'def': lambda _: '/usr/bin/python2.7',
     'prompt': 'What is the location of your python 2.7 binary'},

    {'key': 'java_home',
     'def': lambda _: '/usr/lib/jvm/java-7-common',
     'prompt': 'Where is your jvm installation'},

    {'key': 'cc_port',
     'def': lambda _: '10101',
     'prompt': 'Port to use for provenance server communications.'},

    {'key': 'debug_mode',
     'def': lambda _: False,
     'prompt': 'Set OPUS to debug mode'}
]


BASH_VAR_TEMPLATE = """\
#Auto generated by opusctl
export PATH=$PATH:{bin_dir}
export PYTHONPATH=$PYTHONPATH:{lib_dir}:{py_dir}
export PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION=cpp
export OPUS_MASTER_CONFIG={conf_loc}
"""


BACKEND_CONFIG_TEMPLATE = """\
LOGGING:
  version: 1
  formatters:
    full:
      format: \"%(asctime)s %(levelname)s L%(lineno)d -> %(message)s\"
  handlers:
    file:
      class: logging.FileHandler
      level: DEBUG
      formatter: full
      filename: {log_file}
  root:
    level: {log_level}
    handlers: [file]

MODULES:
  Producer: SocketProducer
  Analyser: PVMAnalyser
  CommandInterface: TCPInterface

PRODUCER:
  SocketProducer:
    comm_mgr_type: UDSCommunicationManager
    comm_mgr_args:
        uds_path: {uds_sock}
        max_conn: 10
        select_timeout: 5.0

ANALYSER:
  PVMAnalyser:
    storage_type: DBInterface
    storage_args:
      filename: {db_path}
    opus_lite: true

COMMANDINTERFACE:
  TCPInterface:
    listen_addr: localhost
    listen_port: {cc_port}

GENERAL:
  touch_file: {touch_file}
"""


def auto_read_config(func):
    @functools.wraps(func)
    def inner(config, *args, **kwargs):
        return func(cfg=load_config(config),
                    *args,
                    **kwargs)
    return inner


@memoised
def compute_config_check(cfg):
    sha1 = hashlib.sha1()

    cfg_str = yaml.dump(cfg)
    sha1.update(cfg_str)
    return cfg_str, sha1.hexdigest()


def is_opus_active():
    return ("LD_PRELOAD" in os.environ and
            "libopusinterpose.so" in os.environ['LD_PRELOAD'] and
            ("OPUS_INTERPOSE_MODE" in os.environ and
             os.environ['OPUS_INTERPOSE_MODE'] != "0"))


def read_config(config_path):
    if os.path.exists(config_path):
        try:
            with open(config_path, "r") as cfg_file:
                check = cfg_file.readline().rstrip()
                return (check, yaml.load(cfg_file.read()))
        except [yaml.error.YAMLError, IOError]:
            raise FailedConfigError()
    else:
        raise FailedConfigError()


def write_config(config_path, cfg):
    config_path = path_normalise(config_path)
    cfg_str, cfg_check = compute_config_check(cfg)
    with open(config_path, "w") as cfg_file:
        cfg_file.write(cfg_check)
        cfg_file.write("\n")
        cfg_file.write(cfg_str)


def load_config(config_path=CONFIG_PATH):
    try:
        check, cfg = read_config(config_path)
    except FailedConfigError:
        print("Error: Your config file is missing.")
        resp = raw_input("Do you want to regenerate it? [Y/n]")
        if resp == "" or resp.upper() == "Y":
            cfg = generate_config()
            check = ""
        else:
            raise

    _, cfg_check = compute_config_check(cfg)
    if check != cfg_check:
        update_config_subsidiaries(cfg)
        write_config(config_path, cfg)
    return cfg


def update_config_subsidiaries(cfg):
    print("Config file modified, applying...")
    generate_bash_var_file(cfg)
    generate_backend_cfg_file(cfg)
    print("Application complete.")


def generate_config(existing=None):
    if existing is None:
        existing = {}
    cfg = {}

    for quest in CONFIG_SETUP:
        if quest['key'] in existing:
            default = existing[quest['key']]
        else:
            default = quest['def'](cfg)
        prompt = "{} [{}]:".format(quest['prompt'], default)
        resp = raw_input(prompt)
        if resp == "":
            cfg[quest['key']] = default
        else:
            cfg[quest['key']] = resp

    return cfg


def generate_bash_var_file(cfg):
    var_file_path = path_normalise(cfg['bash_var_path'])

    with open(var_file_path, "w") as var_file:
        var_file.write(
            BASH_VAR_TEMPLATE.format(
                bin_dir=path_normalise(
                    os.path.join(cfg['install_dir'], "bin")
                ),
                lib_dir=path_normalise(
                    os.path.join(cfg['install_dir'], "lib")
                ),
                py_dir=path_normalise(
                    os.path.join(cfg['install_dir'], "src", "backend")
                ),
                conf_loc=path_normalise(
                    cfg['master_config']
                )
            )
        )


def generate_backend_cfg_file(cfg):
    backend_cfg_path = path_normalise(os.path.join(cfg['install_dir'],
                                                   "opus-cfg.yaml"))

    log_level = "DEBUG" if cfg['debug_mode'] else "ERROR"
    log_file = path_normalise(os.path.join(cfg['install_dir'], "opus.log"))
    uds_sock = path_normalise(cfg['uds_path'])
    db_path = path_normalise(cfg['db_path'])
    touch_file = path_normalise(os.path.join(cfg['install_dir'], ".opus-live"))
    cc_port = cfg['cc_port']

    with open(backend_cfg_path, "w") as backend_cfg:
        backend_cfg.write(
            BACKEND_CONFIG_TEMPLATE.format(
                log_level=log_level,
                log_file=log_file,
                uds_sock=uds_sock,
                db_path=db_path,
                touch_file=touch_file,
                cc_port=cc_port))


def is_backend_active(cfg):
    opus_pid_file = path_normalise(os.path.join(cfg['install_dir'], ".pid"))
    try:
        with open(opus_pid_file, "r") as p_file:
            opus_pid = int(p_file.read())
    except IOError:
        return False

    try:
        opus = psutil.Process(opus_pid)
    except psutil.NoSuchProcess:
        return False

    cmd_str = ' '.join(opus.cmdline())
    return "run_server.py" in cmd_str


def start_opus_backend(cfg):
    if is_opus_active():
        os.environ['OPUS_INTERPOSE_MODE'] = "0"
    if 'JAVA_HOME' not in os.environ:
        os.environ['JAVA_HOME'] = cfg['java_home']

    try:
        pid = os.fork()
        if pid > 0:
            return
    except OSError:
        sys.exit(1)

    os.chdir(path_normalise(cfg['install_dir']))
    os.setsid()
    os.umask(0)

    try:
        pid = os.fork()
        if pid > 0:
            sys.exit(0)
    except OSError:
        sys.exit(1)

    err_log = path_normalise(os.path.join(cfg['install_dir'], "opus_err.log"))
    sys.stdout.flush()
    sys.stderr.flush()
    sti = file("/dev/null", 'r')
    sto = open(err_log, 'w+')
    os.dup2(sti.fileno(), sys.stdin.fileno())
    os.dup2(sto.fileno(), sys.stdout.fileno())
    os.dup2(sto.fileno(), sys.stderr.fileno())
    sto.close()

    opus_pid_file = path_normalise(os.path.join(cfg['install_dir'],
                                                ".pid"))

    backend_cfg_path = path_normalise(os.path.join(cfg['install_dir'],
                                                   "opus-cfg.yaml"))
    run_server_path = path_normalise(os.path.join(cfg['install_dir'],
                                                  "src", "backend",
                                                  "run_server.py"))

    try:
        pid = os.fork()
        if pid > 0:
            os.waitpid(pid, 0)
        else:
            pid = str(os.getpid())
            p_file = open(opus_pid_file, 'w+')
            p_file.write(pid)
            p_file.close()
            os.execvp(cfg['python_binary'],
                      [cfg['python_binary'],
                       "-O",
                       run_server_path,
                       backend_cfg_path])
    except OSError:
        sys.exit(1)

    os.unlink(opus_pid_file)


@auto_read_config
def handle_launch(cfg, binary, arguments):
    if not is_backend_active(cfg):
        print("Attempting to start OPUS backend.")
        start_opus_backend(cfg)

    opus_preload_lib = path_normalise(os.path.join(cfg['install_dir'],
                                                   'lib',
                                                   'libopusinterpose.so'))
    if 'LD_PRELOAD' in os.environ:
        if opus_preload_lib not in os.environ['LD_PRELOAD']:
            os.environ['LD_PRELOAD'] = (os.environ['LD_PRELOAD'] + " " +
                                        opus_preload_lib)
    else:
        os.environ['LD_PRELOAD'] = opus_preload_lib

    os.environ['OPUS_UDS_PATH'] = path_normalise(cfg['uds_path'])
    os.environ['OPUS_MSG_AGGR'] = "1"
    os.environ['OPUS_MAX_AGGR_MSG_SIZE'] = "65536"
    os.environ['OPUS_LOG_LEVEL'] = "3"  # Log critical
    os.environ['OPUS_INTERPOSE_MODE'] = "1"  # OPUS lite

    os.execvp(binary, [binary] + arguments)


@auto_read_config
def handle_exclude(cfg, binary, arguments):
    if is_opus_active():
        os.environ['OPUS_INTERPOSE_MODE'] = "0"
    else:
        print("OPUS is not active.")
    os.execvp(binary, [binary] + arguments)


def handle_start(cfg):
    '''Starts OPUS backend.'''
    if not is_backend_active(cfg):
        print("Attempting to start OPUS backend.")
        start_opus_backend(cfg)
    else:
        print("OPUS backend already running.")


def handle_process(cmd, **params):
    if cmd == "launch":
        handle_launch(**params)
    elif cmd == "exclude":
        handle_exclude(**params)


@auto_read_config
def handle_server(cfg, cmd, **params):
    if cmd == "start":
        handle_start(cfg=cfg, **params)
    else:
        if not is_backend_active(cfg):
            print("Server is not running.")
            return
        helper = cc_utils.CommandConnectionHelper("localhost",
                                                  int(cfg['cc_port']))

        cmd_msg = cc_msg.CmdCtlMessage()
        cmd_msg.cmd_name = cmd

        for k, val in params:
            arg = cmd_msg.args.add()
            arg.key = k
            arg.value = str(val)

        pay = helper.make_request(cmd_msg)

        if isinstance(pay, cc_msg.PSMessageRsp):
            tab = prettytable.PrettyTable(['Pid', 'Thread Count'])
            print("Interposed Processes:\n\n")
            for psdat in pay.ps_data:
                tab.add_row([psdat.pid, psdat.thread_count])
            print(tab)
        elif isinstance(pay, cc_msg.StatusMessageRsp):
            print_status_rsp(pay)
        else:
            print(pay.rsp_data)


def handle_conf(config):
    try:
        _, cfg = read_config(config)
    except FailedConfigError:
        cfg = {}

    if config is not None:
        cfg['master_config'] = config

    new_cfg = generate_config(cfg)

    update_config_subsidiaries(new_cfg)

    write_config(new_cfg['master_config'], new_cfg)


def print_status_rsp(pay):
    '''Prints status response to stdout'''
    stat_str_table = {cc_msg.LIVE: "Alive",
                      cc_msg.DEAD: "Not running",
                      cc_msg.NOT_PRESENT: "Not present"}

    print("{0:<20} {1:<12}".format("Producer",
                                   stat_str_table[pay.producer_status]))

    if pay.analyser_status.HasField("num_msgs"):
        num_msgs = pay.analyser_status.num_msgs
        print("{0:<20} {1:<12} {2:<20}".format(
            "Analyser",
            stat_str_table[pay.analyser_status.status],
            "(" + str(num_msgs) + " msgs in queue)"))
    else:
        print("{0:<20} {1:<12}".format(
            "Analyser",
            stat_str_table[pay.analyser_status.status]))

    print("{0:<20} {1:<12}".format("Query Interface",
                                   stat_str_table[pay.query_status]))


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("--config", required=False, default=CONFIG_PATH,
                        help="Path to OPUS master config file.")

    group_parser = parser.add_subparsers(dest="group")
    proc_parser = group_parser.add_parser(
        "process",
        help="Commands for launching processes with or without OPUS "
             "interposition.")
    server_parser = group_parser.add_parser(
        "server",
        help="Commands for controlling the provenance collection server.")
    group_parser.add_parser(
        "conf",
        help="Configuration of the OPUS environment.")

    proc_cmds = proc_parser.add_subparsers(dest="cmd")

    launch = proc_cmds.add_parser(
        "launch",
        help="Launch a process under OPUS.")
    launch.add_argument(
        "binary", nargs='?', default=os.environ['SHELL'],
        help="The binary to be launched. Defaults to the current shell.")
    launch.add_argument(
        "arguments", nargs=argparse.REMAINDER,
        help="Any arguments to be passed.")

    exclude = proc_cmds.add_parser(
        "exclude",
        help="Launch a process excluded from OPUS interposition.")
    exclude.add_argument(
        "binary", nargs='?', default=os.environ['SHELL'],
        help="The binary to be launched. Defaults to the current shell.")
    exclude.add_argument(
        "arguments", nargs=argparse.REMAINDER,
        help="Any arguments to be passed.")

    server_cmds = server_parser.add_subparsers(dest="cmd")
    server_cmds.add_parser(
        "start",
        help="Start the OPUS provenance collection server.")
    server_cmds.add_parser(
        "stop",
        help="Stop the OPUS provenance collection server.")
    server_cmds.add_parser(
        "ps",
        help="Display a list of processes currently being interposed.")
    server_cmds.add_parser(
        "status",
        help="Display a status readout for the provenance collection server.")

    detach_parser = server_cmds.add_parser(
        "detach",
        help="Deactivates OPUS interposition on a running process.")
    detach_parser.add_argument(
        "pid", type=int,
        help="The PID requiring interposition deactivation.")

    server_cmds.add_parser("getan")

    setan_parser = server_cmds.add_parser("setan")
    setan_parser.add_argument("new_an")

    return parser.parse_args()


def main():
    args = parse_args()

    params = {k: v for k, v in args._get_kwargs() if k != 'group'}

    try:
        if args.group == "process":
            handle_process(**params)
        elif args.group == "server":
            handle_server(**params)
        elif args.group == "conf":
            handle_conf(**params)
    except FailedConfigError:
        print("Failed to execute command due to insufficient configuration. "
              "Please run the '{} conf' command "
              "to reconfigure the program.".format(sys.argv[0]))

if __name__ == "__main__":
    main()
