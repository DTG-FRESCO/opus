# -*- coding: utf-8 -*-
from __future__ import absolute_import, division, print_function

import os
import functools
import hashlib

from . import utils
from .ext_deps import yaml

DEFAULT_CONFIG_PATH = "~/.opus-cfg"

if 'OPUS_MASTER_CONFIG' in os.environ:
    CONFIG_PATH = utils.path_normalise(os.environ['OPUS_MASTER_CONFIG'])
else:
    CONFIG_PATH = utils.path_normalise(DEFAULT_CONFIG_PATH)

CONFIG_SETUP = [
    {'key': 'master_config',
     'def': lambda _: DEFAULT_CONFIG_PATH,
     'prompt': 'Choose a location for the OPUS master config'},

    {'key': 'install_dir',
     'def': lambda _: '~/.opus',
     'prompt': 'Where is your OPUS installation?'},

    {'key': 'server_addr',
     'def': lambda cfg: "unix://" + os.path.join(cfg['install_dir'],
                                                 'uds_sock'),
     'prompt': 'Choose an address for provenance data collection.'},

    {'key': 'db_path',
     'def': lambda cfg: os.path.join(cfg['install_dir'], 'prov.neo4j'),
     'prompt': 'Choose a location for the OPUS database to reside in'},

    {'key': 'bash_var_path',
     'def': lambda _: '~/.opus-vars',
     'prompt': 'Choose a location for the OPUS bash variables cfg_file'},

    {'key': 'python_binary',
     'def': lambda _: '/usr/bin/python2.7',
     'prompt': 'What is the location of your python 2.7 binary?'},

    {'key': 'java_home',
     'def': lambda _: '/usr/lib/jvm/java-7-common',
     'prompt': 'Where is your jvm installation?'},

    {'key': 'cc_addr',
     'def': lambda _: 'tcp://localhost:10101',
     'prompt': 'Address to use for provenance server communications.'},

    {'key': 'debug_mode',
     'def': lambda _: False,
     'prompt': 'Set OPUS to debug mode'}
]


BASH_VAR_TEMPLATE = """\
#Auto generated by opusctl
export PATH=$PATH:{bin_dir}
export OPUS_MASTER_CONFIG={conf_loc}
"""


SERVER_CONFIG_TEMPLATE = """\
LOGGING:
  version: 1
  formatters:
    full:
      format: \"%(asctime)s %(levelname)s L%(lineno)d -> %(message)s\"
  handlers:
    file:
      class: logging.FileHandler
      level: DEBUG
      formatter: full
      filename: {log_file}
  root:
    level: {log_level}
    handlers: [file]

MODULES:
  Producer: SocketProducer
  Analyser: StatisticsAnalyser

PRODUCER:
  SocketProducer:
    comm_mgr_type: MultiCommunicationManager
    comm_mgr_args:
        addr: {server_addr}
        max_conn: 10
        select_timeout: 5.0

ANALYSER:
  StatisticsAnalyser:
    storage_type: DBInterface
    storage_args:
      filename: {db_path}
    opus_lite: true
    opus_snapshot_dir: {opus_home}

ANALYSER_CONTROLLER:
  mem_mon_params:
    mon_status: ON
    mon_interval: 5.0
  memory_params:
    max_rss_threshold: null
    jvm_usage_threshold: 0.90
    min_percent_avail_mem: 0.25
    max_rss_percent_mem: 0.35

NEO4J_PARAMS:
  max_jvm_heap_size: default
  min_jvm_heap_size: default
  jvm_from_avail_mem: 0.25
  buffer_cache:
    buffer_cache_size: default
    buff_cache_auto: 0.25
    propstore: 0.20
    nodestore: 0.20
    relstore: 0.30
    strings: 0.15
    arrays: 0.15
  keep_logical_logs: false
  cache_type: weak

COMMAND:
  listen_addr: {cc_addr}

GENERAL:
  touch_file: {touch_file}
"""


class OPUSctlError(Exception):
    pass


class FailedConfigError(OPUSctlError):
    pass


def auto_read_config(func):
    @functools.wraps(func)
    def inner(conf, *args, **kwargs):
        return func(cfg=load_config(conf),
                    *args,
                    **kwargs)
    return inner


def skip_config(func):
    @functools.wraps(func)
    def wrap(conf, *args, **kwargs):  # pylint: disable=unused-argument
        # Disable needed as args are passed by keyword
        return func(*args, **kwargs)
    return wrap


def compute_config_check(cfg):
    sha1 = hashlib.sha1()

    cfg_str = yaml.dump(cfg)
    sha1.update(cfg_str)
    return cfg_str, sha1.hexdigest()


def read_config(config_path):
    if os.path.exists(config_path):
        try:
            with open(config_path, "r") as cfg_file:
                check = cfg_file.readline().rstrip()
                return (check, yaml.load(cfg_file.read()))
        except [yaml.error.YAMLError, IOError]:
            raise FailedConfigError()
    else:
        raise FailedConfigError()


def write_config(config_path, cfg):
    config_path = utils.path_normalise(config_path)
    cfg_str, cfg_check = compute_config_check(cfg)
    with open(config_path, "w") as cfg_file:
        cfg_file.write(cfg_check)
        cfg_file.write("\n")
        cfg_file.write(cfg_str)


def load_config(config_path=CONFIG_PATH):
    try:
        check, cfg = read_config(config_path)
    except FailedConfigError:
        print("Error: Your config file is missing.")
        resp = raw_input("Do you want to regenerate it? [Y/n]")
        if resp == "" or resp.upper() == "Y":
            cfg = generate_config()
            check = ""
        else:
            raise

    _, cfg_check = compute_config_check(cfg)
    if check != cfg_check:
        update_config_subsidiaries(cfg)
        write_config(config_path, cfg)
    return cfg


def update_config_subsidiaries(cfg):
    print("Config file modified, applying...")
    generate_bash_var_file(cfg)
    generate_server_cfg_file(cfg)
    print("Application complete.")


def generate_config(existing=None):
    if existing is None:
        existing = {}
    cfg = {}

    for quest in CONFIG_SETUP:
        if quest['key'] in existing:
            default = existing[quest['key']]
        else:
            default = quest['def'](cfg)
        prompt = "{} [{}]: ".format(quest['prompt'], default)
        resp = raw_input(prompt)
        if resp == "":
            cfg[quest['key']] = default
        else:
            cfg[quest['key']] = resp

    return cfg


def generate_bash_var_file(cfg):
    var_file_path = utils.path_normalise(cfg['bash_var_path'])

    with open(var_file_path, "w") as var_file:
        var_file.write(
            BASH_VAR_TEMPLATE.format(
                bin_dir=utils.path_normalise(
                    os.path.join(cfg['install_dir'], "bin")
                ),
                conf_loc=utils.path_normalise(
                    cfg['master_config']
                )
            )
        )


def generate_server_cfg_file(cfg):
    server_cfg_path = utils.path_normalise(os.path.join(cfg['install_dir'],
                                                        "opus-cfg.yaml"))

    log_level = "DEBUG" if cfg['debug_mode'] else "ERROR"
    log_file = utils.path_normalise(os.path.join(cfg['install_dir'],
                                                 "opus.log"))
    server_addr = cfg['server_addr']
    db_path = utils.path_normalise(cfg['db_path'])
    touch_file = utils.path_normalise(os.path.join(cfg['install_dir'],
                                                   ".opus-live"))
    opus_home = utils.path_normalise(cfg['install_dir'])
    cc_addr = cfg['cc_addr']

    with open(server_cfg_path, "w") as server_cfg:
        server_cfg.write(
            SERVER_CONFIG_TEMPLATE.format(
                log_level=log_level,
                log_file=log_file,
                server_addr=server_addr,
                db_path=db_path,
                touch_file=touch_file,
                opus_home=opus_home,
                cc_addr=cc_addr))
